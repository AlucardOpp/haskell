-- Определи следующие функции с использованием функций высшего порядка:
-- 1) Функция вычисления арифметического среднего элементов списка вещественных чисел с использованием функции foldr. Функция должна осуществлять только один проход по списку.
-- 2) Функция, вычисляющая скалярное произведение двух списков (используйте функции foldr и zipWith).
-- 3) Функция countEven, возвращающая количество четных элементов в списке.
-- 4) Функция quicksort, осуществляющая быструю сортировку списка по следующему рекурсивному алгоритму. Для того, чтобы отсортировать список xs, из него выбирается первый элемент (обозначим его x). Остальной список делится на две части: список, состоящий из элементов xs, меньших x и спи- сок элементов, больших x. Эти списки сортируются (здесь проявляется рекурсия, поскольку они сортируются этим же алгоритмов), а затем из них составляется результирующий список вида as ++ [x] ++ bs, где as и bs — отсортированные списки меньших и больших элементов соответственно.
-- 5) Определенная в предыдущем пункте функция quicksort сортирует список в порядке возрастания. Обобщите ее: пусть она принимает еще один аргумент — функцию сравнения типа a -> a -> Bool и сортирует список в соответствие с нею.

-- average - это функция, которая принимает на вход список вещественных чисел и возвращает вещественное число
average :: [Double] -> Double
-- average xs - это сопоставление с образцом, которое проверяет, равно ли значение xs, если да, то возвращает значение (foldr (+) 0 xs) / (fromIntegral (length xs)), иначе возвращает значение 0
average xs = (foldr (+) 0 xs) / (fromIntegral (length xs))

-- scalarProduct - это функция, которая принимает на вход два списка вещественных чисел и возвращает вещественное число
scalarProduct :: [Double] -> [Double] -> Double
-- scalarProduct xs ys - это сопоставление с образцом, которое проверяет, равно ли значение xs, если да, то возвращает значение (foldr (+) 0 (zipWith (*) xs ys)), иначе возвращает значение 0
scalarProduct xs ys = foldr (+) 0 (zipWith (*) xs ys)

-- countEven - это функция, которая принимает на вход список целых чисел и возвращает целое число
countEven :: [Integer] -> Integer
-- countEven xs - это сопоставление с образцом, которое проверяет, равно ли значение xs, если да, то возвращает значение (foldr (+) 0 (map (\x -> if x `mod` 2 == 0 then 1 else 0) xs)), иначе возвращает значение 0
countEven xs = foldr (+) 0 (map (\x -> if x `mod` 2 == 0 then 1 else 0) xs)

-- quicksort - это функция, которая принимает на вход список вещественных чисел и возвращает список вещественных чисел
quicksort :: [Double] -> [Double]
-- quicksort xs - это сопоставление с образцом, которое проверяет, равно ли значение xs, если да, то возвращает значение (quicksort [y | y <- xs, y < x] ++ [x] ++ quicksort [y | y <- xs, y > x]), иначе возвращает значение []
quicksort [] = []
-- quicksort (x:xs) - это сопоставление с образцом, которое проверяет, равно ли значение (x:xs), если да, то возвращает значение (quicksort [y | y <- xs, y < x] ++ [x] ++ quicksort [y | y <- xs, y > x]), иначе возвращает значение []
quicksort (x:xs) = quicksort [y | y <- xs, y < x] ++ [x] ++ quicksort [y | y <- xs, y > x]

-- quicksort' - это функция, которая принимает на вход функцию сравнения типа a -> a -> Bool и список вещественных чисел и возвращает список вещественных чисел
quicksort' :: (a -> a -> Bool) -> [a] -> [a]
-- quicksort' fc xs - это сопоставление с образцом, которое проверяет, равно ли значение xs, если да, то возвращает значение (quicksort' fc [y | y <- xs, fc y x]) ++ [x] ++ (quicksort' fc [y | y <- xs, not $ fc y x]), иначе возвращает значение []
quicksort' fc [] = []
-- quicksort' fc (x:xs) - это сопоставление с образцом, которое проверяет, равно ли значение (x:xs), если да, то возвращает значение (quicksort' fc (filter (fc x) xs)) ++ [x] ++ (quicksort' fc (filter (\y -> not $ fc x y) xs)), иначе возвращает значение []
quicksort' fc (x:xs) = quicksort' fc (filter (fc x) xs) ++ [x] ++ (quicksort' fc (filter (\y -> not $ fc x y) xs))

main = do
  print (average [1, 2, 3, 4, 5])
  print (scalarProduct [1, 2, 3, 4, 5] [1, 2, 3, 4, 5])
  print (countEven [1, 2, 3, 4, 5])
  print (quicksort [1, 2, 3, 4, 5])
  print (quicksort'(<) [4, 2, 5, 7, 1, 3, 2])
  print (quicksort'(>) [4, 2, 5, 7, 1, 3, 2])